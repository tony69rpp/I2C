## **Методическое Руководство по Работе с MPU6050 и STM32**

**Протокол связи:** I2C (Inter-Integrated Circuit)

### 1\. Подготовка и Физическое Подключение

#### 1.1. Настройка I2C на STM32

  * **Активация:** В конфигураторе (например, STM32CubeMX) активировать необходимый модуль I2C (например, **I2C2**) в режиме **Master**.
  * **Настройка контактов (SDA/SCL):** Назначенные пины должны быть настроены на **Alternate Function Open Drain** (Альтернативная функция с открытым стоком). Рекомендуется использовать внешние подтягивающие резисторы (Pull-up) на линиях SDA и SCL (обычно 4.7 кОм).
  * **Структура-хэндлер:** Код использует глобальную структуру **`I2C_HandleTypeDef hi2c2`** для взаимодействия с периферией.

#### 1.2. Адрес Датчика

  * **7-битный адрес:** **0x68** (если пин AD0 подключен к GND).
  * **8-битный адрес:** В коде используется **0xD0** (для записи) и **0xD1** (для чтения), что является $0x68 \ll 1$.

### 2\. Инициализация MPU6050

Инициализация выполняется функцией **`MPU6050_Init()`** и включает два ключевых шага:

1.  **Проверка Подключения (WHO\_AM\_I):**

      * **Цель:** Проверить, отвечает ли датчик.
      * **Действие:** Чтение регистра **WHO\_AM\_I** (адрес **0x75**).
      * **Ожидаемое значение:** **0x68**.

2.  **Вывод из Спящего Режима:**

      * **Цель:** Перевести датчик в активный режим.
      * **Действие:** Запись значения **0x00** в регистр **PWR\_MGMT\_1** (адрес **0x6B**).
      * **Результат:** Датчик начинает использовать внутренний тактовый генератор и готов к работе.

### 3\. Чтение и Обработка Данных

Чтение и обработка выполняются функцией **`MPU6050_Read_All(MPU6050_Data* data)`**.

#### 3.1. Чтение Сырых Данных

  * Считывается блок из **14 байт**, начиная с регистра **ACCEL\_XOUT\_H** (адрес **0x3B**).
  * Байты содержат 16-битные данные для: Акселерометра (X, Y, Z), Температуры и Гироскопа (X, Y, Z).

#### 3.2. Преобразование в Физические Величины

Полученные 16-битные сырые значения (`int16_t`) масштабируются для получения реальных физических единиц. В коде используются настройки по умолчанию:

  * **Акселерометр (g):**
      * **Чувствительность:** 16384 LSB/g (для диапазона $\pm 2g$).
      * **Формула:** $a = a_{raw} / 16384.0$
  * **Гироскоп ($^\circ/\text{s}$):**
      * **Чувствительность:** 131 LSB/($^\circ/\text{s}$) (для диапазона $\pm 250^\circ/\text{s}$).
      * **Формула:** $g = g_{raw} / 131.0$
  * **Температура ($^\circ\text{C}$):**
      * **Формула:** $T = (T_{raw} / 340.0) + 36.53$

### 4\. Расчет Углов Наклона (Статический)

Функция **`MPU6050_Calculate_Angles()`** использует данные акселерометра для определения статических углов наклона (Roll и Pitch).

  * **Roll (Крен):** Угол вращения вокруг оси X.
    $$\text{Roll} = \text{atan2}(a_y, a_z) \cdot \frac{180}{\pi}$$
  * **Pitch (Тангаж):** Угол вращения вокруг оси Y.
    $$\text{Pitch} = \text{atan2}(-a_x, \sqrt{a_y^2 + a_z^2}) \cdot \frac{180}{\pi}$$

### 5\. Пример Интеграции в Основной Цикл

Для непрерывной работы датчика в основной программе (`main.c`):

1.  **Инициализация:** Вызвать **`MPU6050_Init()`** один раз при старте.
2.  **Цикл Чтения:** В цикле `while(1)` регулярно вызывать **`MPU6050_Read_All(&mpu_data)`** и использовать полученные поля структуры `mpu_data` (`roll`, `pitch`, `temp_c` и т.д.) для управления или вывода.

<!-- end list -->

```c
// Внутри while(1)
MPU6050_Data mpu_data;

// Чтение и расчет
MPU6050_Read_All(&mpu_data); 

// Использование данных
// Пример: Управление светодиодом, если угол Roll превышает 10 градусов
if (fabs(mpu_data.roll) > 10.0) {
    // Включить предупреждающий светодиод
}

// Задержка перед следующим измерением
HAL_Delay(50);
```
